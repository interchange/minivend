#!/usr/bin/perl
#
# offline - MiniVend database builder and indexer
#
# $Id: offline,v 1.7 1998/05/06 08:35:19 mike Exp $
#
# This program is largely based on Vend 0.2
# Copyright 1995 by Andrew M. Wilcox <awilcox@world.std.com>
#
# Portions from Vend 0.3
# Copyright 1995 by Andrew M. Wilcox <awilcox@world.std.com>
#
# Enhancements made by and
# Copyright 1996-1998 by Michael J. Heins <mikeh@minivend.com>
#
# See the file 'Changes' for information.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

BEGIN {
    eval {
        require 5.004;
        require FindBin;
		1 and $Global::VendRoot = $FindBin::RealBin;
        1 and $Global::VendRoot =~ s/.bin$//;
    };
	($Global::VendRoot = $ENV{MINIVEND_ROOT})
		if defined $ENV{MINIVEND_ROOT};

	$Global::VendRoot = $Global::VendRoot || '/home/minivend';
}

### END CONFIGURABLE VARIABLES

$Global::ConfigFile = 'minivend.cfg';
$Global::ErrorFile = "$Global::VendRoot/error.log";

use lib "$Global::VendRoot/lib";
use Vend::Util qw/logError/;

my $DEBUG = 0;

sub dontwarn { $FindBin::RealBin; }

use strict;
use Fcntl;

#select a DBM

BEGIN {

	$Global::GDBM = $Global::DB_File = $Global::DBI = $Global::Msql = 0;
    AUTO: {
		# This is for standard DBI
		eval {require DBI and $Global::DBI = 1};
        last AUTO if
            (defined $ENV{MINIVEND_DBFILE} and $Global::DB_File = 1);
        last AUTO if
			(defined $ENV{MINIVEND_NODBM});
        eval {require GDBM_File and $Global::GDBM = 1} ||
        eval {require DB_File and $Global::DB_File = 1};
    }
	if($Global::GDBM) {
		require Vend::Table::GDBM;
		import GDBM_File;
		$Global::GDBM = 1;
	}
	elsif($Global::DB_File) {
		require Vend::Table::DB_File;
		import DB_File;
		$Global::DB_File = 1;
	}
	elsif(! $Global::DBI) {
		die "No DBM defined! Offline import not necessary.\n";
	}
}

use Vend::Config;
use Vend::Data;

my $USAGE = <<EOF;
usage: offline -c catalog [-d offline_dir]

If specifying a subcatalog, make sure the databases to be built
are defined in the subcatalog definition.  If they are in the base
catalog, use that catalog as the parameter for the -c directive.
EOF

my ($catalog,$directory,$delimiter);
my (@Indices);

GETOPT: {

	if($ARGV[0] eq '-c') {
		shift(@ARGV);
		$catalog = shift(@ARGV);
		redo GETOPT;
	}
	elsif($ARGV[0] eq '-d') {
		shift(@ARGV);
		$directory = shift(@ARGV);
		redo GETOPT;
	}
	elsif($ARGV[0] !~ /^-/) {
		push(@Indices, @ARGV); 
		@ARGV = ();
		last GETOPT;
	}

} # END GETOPT

die "Unrecognized args, aborting.\n$USAGE\n" 
		if @ARGV;

die $USAGE unless defined $catalog;

my($name,$dir,$param,$subcat,$subconfig);
chdir $Global::VendRoot;
open(GLOBAL, $Global::ConfigFile) or
	die "No global configuration file? Aborting.\n";
while(<GLOBAL>) {
	next unless /^\s*(sub)?catalog\s+$catalog\s+/i;
	$subcat = $1 || '';
	chomp;
	s/^\s+//;
	unless($subcat) {
		(undef,$name,$dir,$param) = split /\s+/, $_, 4;
	}
	else {
		(undef,$name,$subconfig,$dir,$param) = split /\s+/, $_, 5;
	}
	last;

}
close GLOBAL;

global_config();

chdir $dir or die "Couldn't change directory to $dir: $!\n";

$Vend::Cfg = config($name, $dir, 'config', $subconfig || undef);

$Vend::Cfg->{ProductDir} =
		$Vend::Cfg->{DataDir} =  $directory || $Vend::Cfg->{OfflineDir};

open_database();

my $db;
my $obj;

foreach $db (keys %Vend::Database) {
	eval {
		$obj = database_exists_ref($db)
			or warn "Trouble importing $db: $!\n";
		$obj->ref;
		};
	if($@) {
		my $k; my $v;
		my $msg = "Trouble importing $db: $@\n\n";
		while( ($k, $v) = each %{$Vend::Cfg->{Database}{$db}} ) {
			$msg .= sprintf "%15s: %s\n", $k, $v;
		}
		warn "$msg\n";
	}
	print "Done with $db.\n";
}

close_database();

