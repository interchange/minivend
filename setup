#!/usr/bin/perl
# setup:  read configuration file and install application
#
# $Id: setup,v 1.20 1995/12/15 21:55:26 amw Exp $

# Copyright 1995 by Andrew M. Wilcox <awilcox@world.std.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

my $Version = "0.3.3";

use Getopt::Long;
# use strict;

my $Parsers = {
    absolute    => \&parse_absolute,
    timespan    => \&parse_timespan,
    yesno       => \&parse_yesno,
    app_dir     => \&app_dir,
    url         => \&parse_url,
    permission  => \&parse_permission,
    modules     => \&lookup_modules
    };


GetOptions qw(vend=s config=s help version)
    or do {
        usage();
        exit 1;
    };

if ($main::opt_version) {
    version();
    exit 0;
}
if ($main::opt_help) {
    version();
    usage();
    exit 0;
}

my $Vend_lib;
if ($main::opt_vend) {
    $Vend_lib = $main::opt_vend;
    $Vend_lib =~ s,/$,,;
    -f "$Vend_lib/Vend/Dispatch.pm" or die <<"END";
I'm sorry, but I don't see the Vend sources in '$Vend_lib'.
END
}
else {
    my $novend = <<'END';
I'm sorry, I wasn't able to find the Vend directory.  Please
use the -vend option to give the location of the Vend library
directory.
END
    my $dir = $0;
    $dir =~ s,/[^/]+$,, or die $novend;
    die $novend unless -f "$dir/Vend/Dispatch.pm";
    $Vend_lib = $dir;
}

unshift @INC, $Vend_lib;

require Vend::ConfigReader;
$C = new Vend::ConfigReader;
my @Modules = ();

my $App = shift @ARGV;
$App = 'vend' unless defined $App;
configuration();


if ($main::opt_config) { $C->load($main::opt_config) }
elsif (-f "$App.conf") { $C->load("$App.conf") }
elsif (-f "$App.cfg")  { $C->load("$App.cfg") }
elsif (-f "vend.conf") { $C->load("vend.conf") }
elsif (-f "vend.cfg")  { $C->load("vend.cfg") }
else {
    die <<'END';
I'm sorry, but I couldn't find the Vend configuration file
in the current directory.
END
}

my $Data_dir = $C->value("Data_directory");
makedir($Data_dir);
chdir($Data_dir) or die "Can't chdir to '$Data_dir': $!\n";

cmd("$Vend_lib/template/configure");

%syscfg = ();
open(SYSCFG, "syscfg") or die "Can't read 'syscfg': $!\n";
while(<SYSCFG>) {
    if (m/^(\w+)="(.*)"$/) {
        $syscfg{$1} = $2;
    }
}
close(SYSCFG);

my $App_program = $C->value("App_program");
my $time = localtime();
my $user = $ENV{'LOGNAME'} || getlogin() || (getpwuid($<))[0];
my $D = $C->values();
$C->predefine('App', $App);
$C->predefine('Vend_lib', $Vend_lib);
# $D->{'App'} = $App;
# $D->{'Vend_lib'} = $Vend_lib;

my $App_directory = $C->value("App_directory");
makedir($App_directory);
chdir $App_directory or die "Can't chdir to '$App_directory': $!\n";

open(OUT, ">$App_program") or die "Couldn't create '$App_program': $!\n";

print OUT <<"END";
#!$D->{Perl_program} -w
# this file was generated by Vend Setup $Version
# on $time by $user

\$main::Config = \$main::Config = {
    App => \"$App\",
    Vend_lib => \"$Vend_lib\",
END

my ($d, $x);
foreach $d ($C->directives()) {
    print OUT "    ", $d, ' => "';
    $x = $C->value($d);
    $x =~ s/[\x00-\x1F\x7F\\\"\$\@]/sprintf('\x%0.2X', ord($&))/eg;
    print OUT $x, '",', "\n";
}

print OUT <<"END";
};

\$0 = "(Vend) $D->{App_program} \@ARGV";

unshift(\@INC, '$D->{App_lib}', '$Vend_lib');
require Vend::Require;
\$| = 1;

if (open(Vend::Log::ERROR, '>>$D->{Error_file}')) {
    \$Vend::Log::log_open = 1;
    select(Vend::Log::ERROR); \$| = 1; select(STDOUT);
}
else {
    \$Vend::Log::error =              # don't confuse RCS
        \$!;
}

if (defined(\$ENV{'GATEWAY_INTERFACE'})) {
    if (not \$Vend::Log::log_open) {
        print "Content-type: text/plain\\r\\n\\r\\n";
        print "Could not open log file '$D->{Error_file}':\\r\\n";
        print "   \$Vend::Log::error\\r\\n";
        exit 0;
    }

    open(STDERR, ">&Vend::Log::ERROR");

    # Compilation errors are caught here
    eval {
        Vend::Require::Require('Startup.pm');
        Vend::Startup::startup();
    };
    if (\$@) {
        print Vend::Log::ERROR \$@;
        print "Content-type: text/plain\\r\\n\\r\\n";
        print technical_difficulties();
        exit 0;
    }
}

else {
    if (not \$Vend::Log::log_open) {
        print "Could not open log file '$D->{Error_file}':\\n";
        print "   \$Vend::Log::error\\n";
        exit 0;
    }

    require Vend::Startup;
    Vend::Startup::startup();
}

sub technical_difficulties {
    <<"EOM";
<html><head><title>Technical Difficulties</title></head>\\r
\\r
<body><h1>Technical Difficulties</h1>\\r
\\r
We are sorry, but we are currently experiencing technical difficulties\\r
and were unable to complete your request.\\r
\\r
</body></html>\\r
EOM
}
END

close(OUT);
chmod(0755, $App_program) or die "Couldn't chmod '$App_program': $!\n";

my $module;
foreach $module (@Modules) {
    run_in($module, 'config', $C);
}

exit 0;

sub version {
    print STDERR
        "Vend Setup version $Version, Copyright 1995 Andrew M. Wilcox.\n";
}

sub usage {
    print STDERR <<'END';
Usage: perl setup <application name>

   --config <file>      specify config file (defaults to '<app>.conf')
   --help               display this usage information
   --vend <directory>   specify Vend library directory
   --version            display program version
END
}


## Configuration

sub directive {
    my ($directive, $default, $parser_name) = @_;
    my $parser = undef;

    if (defined $parser_name) {
        $parser = $Parsers->{$parser_name};
        die "There is no parser by the name '$parser_name' defined"
            unless defined $parser;
    }

    on $C $directive, $default, $parser;
}

sub configuration {
    directive 'App_directory',     undef,       'absolute';
    directive 'App_lib',           'lib',       'app_dir';
    directive 'App_program',       $App,        'app_dir';

    directive 'Modules',           '',          'modules';

    directive 'Perl_program',      undef,       'absolute';
    directive 'Database',          'gdbm';
    directive 'Sendmail_program',  '/usr/lib/sendmail',
                                                'absolute';

    directive 'Page_URL',          undef,       'url';
    directive 'External_URL',      undef,       'url';
    directive 'Error_file',        'error.log', 'app_dir';
    directive 'Write_permission',  'user',      'permission';
    directive 'Read_permission',   'user',      'permission';

    directive 'Html_extension',    '.html';
    directive 'Page_directory',    'pages',    'app_dir';
    directive 'Data_directory',    'data',     'app_dir';
    directive 'Bin_directory',     'bin',      'app_dir';
    directive 'Phd_directory',     'phd',      'app_dir';
    directive 'Default_page',      'catalog';
    directive 'Display_errors',    'No',       'yesno';
    directive 'Session_expire',    '4 hours',  'timespan';
    directive 'Dump_request',      'No',       'yesno';
    directive 'Dump_session',      'No',       'yesno';
}


#    directive 'Config_file',       'vend.conf', 'app_dir';
#    directive 'Socket_file',       'link.sock', 'app_dir';

sub parse_absolute {
    my ($c, $value) = @_;

    if ($value !~ m!^/!) {
        $c->warning("The " . $c->directive() . " (now set to " .
                    "'$value') should probably start with a leading /.");
    }
    $value =~ s!/$!!;
    $value;
}


# Parses a time specification such as "1 day" and returns the
# number of seconds in the interval, or undef if the string could
# not be parsed.

sub time_to_seconds {
    my ($str) = @_;

    my ($n, $dur) = ($str =~ m/(\d+)\s*(\w+)?/);
    return undef unless defined $n;
    if (defined $dur) {
        $_ = $dur;
        if (m/^s|sec|secs|second|seconds$/i) {
        } elsif (m/^m|min|mins|minute|minutes$/i) {
            $n *= 60;
        } elsif (m/^h|hour|hours$/i) {
            $n *= 60 * 60;
        } elsif (m/^d|day|days$/i) {
            $n *= 24 * 60 * 60;
        } elsif (m/^w|week|weeks$/i) {
            $n *= 7 * 24 * 60 * 60;
        } else {
            return undef;
        }
    }

    $n;
}

sub parse_timespan {
    my ($c, $value) = @_;
    my ($n);

    $n = time_to_seconds($value);
    if (not defined $n) {
        $c->error("Bad time format ('$value') in the " .
                  $c->directive() . " directive");
    }
    $n;
}


# Returns 1 for Yes and 0 for No.

sub parse_yesno {
    my ($c, $value) = @_;

    local ($_) = $value;
    if (m/^y/i || m/^t/i || m/^1/) {
        return 1;
    }
    elsif (m/^n/i || m/^f/i || m/^0/) {
        return 0;
    }
    else {
        $c->error("Use 'yes' or 'no' for the '" . $c->directive() .
                  "' directive");
    }
}


# Prepend the app_dir pathname to the relative directory specified,
# unless it already starts with a leading /.

sub app_dir {
    my ($c, $value) = @_;

    $value = $c->value('App_directory') . "/$value"
        unless $value =~ m!^/!;
    $value =~ s!/$!!;
    $value;
}

sub parse_url {
    my ($c, $value) = @_;

    if ($value !~ m/^http:/i) {
        $c->warning("The " . $c->directive() .
                    " directive (now set " .
                    "to '$value') should probably start with 'http:'");
    }
    
    $value =~ s!/$!!;
    $value;
}


sub parse_permission {
    my ($c, $value) = @_;

    local ($_) = lc($value);
    if ($_ ne 'user' and $_ ne 'group' and $_ ne 'world') {
        $c->error("Permission must be one of 'user', 'group', or " .
                       "'world' for the " . $c->directive() .
                       " directive");
    }
    $_;
}

sub lookup_modules {
    my ($c, $modules) = @_;

    my $app_lib = $c->values()->{"App_lib"};
    $app_lib = $c->value("App_directory")."/lib" unless defined $app_lib;
    my @search = ($app_lib, $Vend_lib);

    my ($m, $module, $lib, $f, $ok);
    @Modules = split(/\s+/, $modules);
    foreach $m (@Modules) {
        $module = $m;
        $module =~ s,::,/,g;
        $ok = 0;
        foreach $lib (@search) {
            $f = "$lib/$module.cf";
            if (-r $f) {
                do $f;
                die $@ if $@;
                # run_in($m, 'directives', $C, \&directive);
                $ok = 1;
                last;
            }
        }
        # die "Module '$module' not found in either '$app_lib'\nor '$Vend_lib'\n"
        #    unless $ok;
    }

    $modules;
}

sub run_in {
    my ($package, $subname, @args) = @_;
    no strict 'refs';
    my $sub = $package . "::" . $subname;

    &{$sub}(@args) if defined &{$sub};
}

sub process_file {
    my ($name, $ext, $dest_dir, $make_executable) = @_;
    
    my $d1 = "$D->{App_lib}/template";
    my $d2 = "$Vend_lib/template";

    open(IN, "$d1/$name$ext")
    or open(IN, "$d2/$name$ext")
    or die "Couldn't find $name$ext in either $d1 or $d2\n";

    makedir($dest_dir);
    my $out = "$dest_dir/$name";
    print "Creating $out\n";
    open(OUT, ">$out") or die "Couldn't create '$out': $!\n";
    while(<IN>) {
        s,\@\@(\w+)\@\@,$C->value($1),eg;
        print OUT $_;
    }
    close(IN);
    close(OUT);
    chmod 0750, $out or die "Couldn't chmod '$out': $!\n" if $make_executable;
}


sub makedir {
    my ($dir) = @_;
    my @path = split(/\//, $dir);
    $root = shift @path;

    my ($i, $path);
    foreach $i (0 .. $#path) {
        $path = join('/', $root, @path[0 .. $i]);
        next if -d $path;
        die "Not a directory: $path\n" if -e $dir;
        print "Creating directory $path\n";
        mkdir $path, 0755 or die "Can't mkdir '$path': $!\n";
    }
}

sub cmd {
    my ($cmd) = @_;

    print "$cmd\n";
    (system($cmd)) == 0 or exit 1;
}
