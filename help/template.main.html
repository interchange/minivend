<html>
<head>
   <title>Tallyman Help: Template Creation</title>
</head>
<body bgcolor="#ffffff" link="#7079aa" alink="#000000" vlink="#999999" >


<style type="text/css">
<!--
A:link {text-decoration: none} 
A:visited {text-decoration: none} 
A:active {text-decoration: none}
A:hover {color:#000000; text-decoration: none}
-->
</style>

<form>
<table width='100%' border=0 cellspacing=0 cellpadding=0><tr><td height=23 bgcolor="#e8a317" background="images/help.background.gif" valign=middle><table width='100%' cols=3 border=0 cellpadding=0 cellspacing=0><tr><td height=1 width=12 align=left valign=middle><img src='images/curve.left.help.gif' width=12 height=22></td><td valign=middle width=550><img src="images/cleardot.gif" height=1 width=12><a href="main.html"><font face="Verdana, Arial, Helvetica, sans-serif" size=2>Home</font></a><img src="images/cleardot.gif" height=1 width=12><a href="faq.html"><font face="Verdana, Arial, Helvetica, sans-serif" size=2>FAQ</font></a><img src="images/cleardot.gif" height=1 width=12</td><td align=right valign=middle width=40><a href='help' target="Help" onclick='return ShowHelp()' onmouseover="window.status='Help';return true;" onmouseout="window.status='';return true;"><font face="Verdana, Arial, Helvetica, sans-serif" size=2>Back</font></a></td><td width=19 align=right valign=middle><img src="images/curve.right.help.gif" width=12 height=22 border=0></td></tr></table></td></tr></table>
</form>

<center>
<table border=0 cellspacing=0 cellpadding=2 width="450">

<tr>
<td>
<br>
<font size="-1" face="Verdana,Arial,Helvetica,sans-serif"><b>Template Creation</b></font> <br>
<br>
<hr noshade size=2 width=100%>
<br>
<pre>

template creation howto
20 sep 1999
jason e holt &lt;jason@akopia.com&gt;

copyright 1999 akopia, inc.

------------------------------



:Contents:
----------
Contents
Introduction
Philosophy
The regeneration process
Pertinent library routines
Pitfalls
Designing a site




:Introduction:
--------------

This document includes some miscellaneous information about the
regeneration system distributed with Tallyman.  It may provide some
extra detail after you have read and understood site_management.txt.
The section on "Designing a site" is helpful when creating a new set
of templates.


:Philosophy:
------------

The set of libraries supplied with TallyMan make very few assumptions
about the organization of your site.  In fact, only the REGEN library
even makes any assumptions about the types of snippets associated with
a thing, and is provided primarily to support a useful set of
conventions in template design.

Customizing a TallyMan installation for a particular installation,
then, consists in trading some of that generality for a site which is
intuitive and easily configured.  In most cases the templates can be
designed in such a way as to make them robust and easily portable to
other applications.


:The regeneration process:
--------------------------

Currently, the container system is used to control site layout and
regeneration order.  The container system is a fairly straightforward
tree structure consisting of references to items, pages, and groups in
the item, page and group_table tables in the database.  It can be
represented in outline form; conventional techspeak designates the
top-level container the "root node", and all subheadings as "child
nodes", or simply "children".  A child node (subheading) may itself
have children (sub-subheadings), etc.

To preserve generality, no restrictions are made by the library on how
the containers are organized.  Since templates tend to be quite
dependant on the organization of the containers, it's quite easy to
confuse the templates by misuse of the container editor.  On the other
hand, since the containers only refer to the things in the database,
rather than representing them directly, deleting or mis-organizing the
containers won't normally affect the actual items, pages or groups in
your system.  Regeneration just won't happen quite as you expect.

The default behavior of the regeneration system is to generate all the
children of the root node by their templates; that is to say, it looks
for a snippet type named "Template" for each top-level container, and
uses that template to generate that thing.  If "Filename" and
"Directory" snippet types are available, the corresponding file will
hold the output of the template.  If not, and an "HTML" snippet type
is available, the result will be stored therein.  Otherwise, the
result is returned to the parent.  An example is in order:

Example site layout:

Tallyman
    (g) Quicklinks
         (g) Site resources 
	      (p) Customer Service
	      (p) Return policy
	      (p) Contacting us
	 (g) Categories 
	      (p) Complete systems
	      (p) Components
	      (p) Software
    (g) Pages
	 (p) Components
	      (g) Sidebar
	           (g) Categories
	      (i) 256MB Memory module
	      (i) PCI Video Card
	      (i) Dual G3 motherboard
	 (p) Software
	      (g) Sidebar
	           (g) Categories
	      (i) Stampede Linux
	      (i) GNU utilities
	      (i) Adobe Photoshop	      
	 (p) Complete systems
	      (g) Sidebar
	           (g) Site resources
	      (i) RAID-5 NFS Server
	      (i) Beowulf node
	      (i) Simple Workstation
	 (p) Customer Service
	      (g) Sidebar
	           (g) Site resources
	 (p) Return policy
	      (g) Sidebar
	           (g) Categories
	 (p) Contacting us
	      (g) Sidebar
	           (g) Site resources
        	      
[Key: (g) = group, (p) = page, (i) = item]


The following things have the snippets shown:

"Sidebar groups", "Pages": 
	 "Template": "generic.epl"


"Site resources", "Categories":
         "Template": "links.epl"
	 "HTML": don't care

"Components":
	 "Template": "prodpage.epl"
	 "Filename": "components.html"

"Software":
	 "Template": "prodpage.epl"
	 "Filename": "software.html"

"Complete Systems":
	 "Template": "prodpage.epl"
	 "Filename": "systems.html"
	 "Sidebar links": "Site resources"

"Customer Service":
	 "Template": "content.epl"
	 "Filename": "service.html"
	 "Sidebar links": "Site resources"

"Return policy":
	 "Template": "content.epl"
	 "Filename": "return_policy.html"
	 "Sidebar links": "Categories"

"Contacting us":
	 "Template": "content.epl"
	 "Filename": "contact.html"
	 "Sidebar links": "Site resources"



In this example, REGEN.pm would first call the "generic.epl" template
for the group named "Sidebar groups", since it's the first top-level
container.  Let's say "generic.epl" generates a container's children
in the same manner as REGEN.pm itself.  Thus it would find the first
container it contains, "Site resources", and attempt to generate it by
its template, in this case "links.epl".

Now let's say that "links.epl" generates a set of "quick links" to all
the pages which are children of the group being generated, and stores
the resulting HTML code in a (hidden) snippet for that group.  Since
the "Site resources" container has as its children the "Customer
Service", "Return policy" and "Contacting us" pages, "links.epl" would
then find the "Filename" snippet for each of those pages and
accordingly generate links to "service.html", "return_policy.html" and
"contact.html".

Following generation of the "Site resources" container, "Sidebar
groups" would then continue by generating "Categories".  "Categories"
would behave similarly to its cousin "Site resources" (since they use
the same template), and generate links to "systems.html",
"components.html" and "software.html".  The HTML would then be stored
in the "HTML" snippet for the "Categories" group.

With the completion of "Sidebar groups", REGEN.pm would now generate
the "Pages" group, which also uses the "generic.epl" template.
"Components", the first child of "Pages", and would be generated with
its "prodpage.epl" template.  

Let's say the "prodpage.epl" template generates an .html page with
descriptions of any items which are its container's children, and
places a quicklinks box off to the side.  Since it's generating the
"Components" container, it would look for a child named "Sidebar",
find its children ("Categories"), and insert the HTML generated
earlier for the "Categories" group.  It would also look up pertinent
snippets for the "256MB Memory module", "PCI Video Card", and "Dual G3
motherboard" items and use the values to generate bits of HTML for
each of those items.  The final result would then be stored in
"components.html".

Similarly, "prodpage.epl" would do its thing for the "Software" and
"Complete systems" containers.  Note that the "Complete systems" page
lists "Site resources" as its quicklinks box, so its sidebar will be
different from the other two pages.

Finally, "content.epl" would be used to generate the HTML files for
the "Customer Service", "Return policy" and "Contacting us" pages.
Just as with the product pages, each of these pages has quicklinks in
a sidebar; "Site Resources" in the case of "Customer Service" and
"Contacting us", and "Categories" in the case of "Return policy".


:Pertinent library routines:
----------------------------

The REGEN library's primary purpose is to make life easier for
template designers.  REGEN keeps track of which containers are
currently being generated, and provides functions to easily get at the
snippets and children corresponding to the container being worked on.

Following is a description of some of the more commonly used REGEN
library functions.  See the comments in the library for itself for
details on all the functions therein.

set_output_location() allows you to tell the regen system what to do
with the HTML generated by the current template.  The first argument
can be "return", "snippet", or "filename".  "return" means to hand the
output of the template to whoever asked for the current template to be
run.  It is most often used when you want the output of a template to
be simply thrown away.  "snippet" means to store the output in the
snippet of the current thing having the name specified as the second
argument to set_output_location().  This is used, for instance, by
Quicklinks groups to store their HTML in a snippet named "HTML".
"filename" means to save the output in a file; the second argument
specifies its name.

attrib() gets information from the current thing's snippets, the knar
table and a supplied set of defaults for any number of supplied
attributes.  This is one of the most useful functions in the REGEN
library.  For instance, if asked for the "Table Background" attribute,
attrib() will first check to see if the thing currently being
generated has a snippet of that name.  Failing that, it will look in
the knar table for a global attribute of that name.  If none exists
there, it will use the default supplied.  Thus choices can be given to
the site maintainer by the template author without the need to
initially implement them in the back office.  If the default table
background ever proves insufficient, the site maintainer need only add
an entry to the knar table to override the default on a site-wide
level.  That attribute could then itself be overridden in only a
certain type of page or group by adding a field of the same name.

snippets() is like attrib(), but doesn't check the knar table.

attrib_cid() and snippets_cid() are like their counterparts, but take
a container id as first argument.

status() allows a message to be printed, indented according to the
current regeneration "level", in the regen status display.  

warning() allows a template to non-fatally complain.  Just like
status(), but emphasizes the message to the user.  




:Pitfalls:
----------

* In designing the various libraries used in generating a site, the
author himself frequently found himself getting terminology crossed.
Frequently, describing what's going on is the most difficult part of
creating (and documenting) a site regen process.  It helps to keep a
few things straight.

First of all, make sure you have some grasp of the idea of thingtypes,
documented elsewhere.  A thing's type determines what kinds of
snippets should be available for a given thing (item, page or group).

The systems of items, pages and groups (and their accompanying types
and snippets) contain most of the information used in generating a
site, but don't themselves contain much information on how (and in
what order) the site will be generated.  That will probably change as
the idea of containers is integrated with the thingtypes, but for now
it's a completely separate system.  Keep that in mind; the CONTAINER
library and its accompanying table could be removed (almost) without
affecting the item, page and group libraries and data.

The container tree serves two purposes:

1. Determine the order in which things will be generated 

2. Allow things to contain other things; that is, to let product pages
contain items, and quicklinks groups contain pages.  How this
parenthood is interpreted is up to the template; that is, a product
page needs to know how to generate descriptions and "buy me" links for
all of its items, while a quicklinks group generates links to each of
its children.

* Remember that the container tree is separate from the things it
describes.  The "Customer Service" page might appear many times in the
container tree, but there is only one actual "Customer Service" page
in the page table.  Deleting it from the container tree, adding
children, placing it in various places doesn't affect the actual
"Customer Service" page.  Things (that is to say, items, pages and
groups) may exist and not be in the container tree at all.  It is
noteworthy, however that the converse is not true; when a thing is
deleted, all reference to it will be removed from the container tree.
This makes sense, really; an item might be created but not immediately
needed in the site's pages, and thus not placed in the container tree.
But it would be meaningless to have an item listed in the container
tree which doesn't actually exist.

* The order of things in the container tree is important to a site's
regeneration.  In the above example, code for sidebar boxes needed to
be generated before the pages which would include them.  If "Pages"
appeared before "Sidebar groups" in the container tree, all of the
pages in the site would have been generated using old (or nonexistant)
HTML snippets for the "Categories" and "Site resources" quicklinks,
and then the up-to-date HTML would be generated for those same
quicklinks.  The site would have to be generated twice to bring
everything up to date.

* If you're not used to thinking recursively, it's easy to get muddled
trying to follow the course of a regeneration pass.  For instance, the
"Categories" group is generated as part of the "Sidebar groups"
generation, which is in turn part of the entire site's generation.  In
general, you don't have to worry about this since REGEN keeps track of
this, and automatically picks up with "Sidebar groups" when
"Categories" finishes, and then continues with the entire site's regen
when "Sidebar groups" finishes.


:Designing a site:
------------------

I find the following method to work best when designing a new set of
templates and an accompanying set of things and types.  Note that
steps 1-4 don't require any knowledge of programming.  For simple
templates, or migration from an existing set of templates, only a
cursory knowledge of Embperl may be necessary.

1. Build prototype pages for your site.  Decide what kinds of pages
   you want to manage with TallyMan, and come up with a mock-up in
   straight HTML.  In designing a store like the one reflected in the
   above example, someone qualified to write Good HTML should have
   first written an example content page, or perhaps several, if for
   instance it was determined that the "Return policy" page needed to
   have a significantly different layout than the "Contacting us"
   page.  Though not shown, an example home page might be created if
   you wanted to maintain it via TallyMan.  A sample product page
   should also have been created.

2. Next, determine what you want to be able to manage from the Back
   Office, and set it up accordingly.  If you want to be able to
   change the background color on a daily basis, go ahead and create a
   field for it for the appropriate page type.  

   At this point, I try not to think too much of how you'll implement
   each option in the template; rather, think of what you'd like to be
   able to do.  If you'd like to be able to change item listings in
   all the product pages in the entire site from staggered left/right
   to center aligned, add an option to do that in the knar table (or
   as a hidden field type, or whatever).  It may turn out to be quite
   easy to implement.

   Also create the fields needed for your item types, and create a few
   sample items.  Determine what fields need to be set, and how
   they'll correspond with their representation on a web page.

3. Next, set up the site layout in a logical style which will be
   reasonably manageable.  Remember that the template will be able to
   interpret the layout anyway it wishes, so choose a layout which
   will let the maintainer control the layout of the site simply and
   intuitively.
   
   (Future releases may allow you to separate configuration options by
   role, so the graphic artist can manage the look of the site while
   the inventory control people manage the actual products.)

4. See what can be factored from the example HTML pages; that is, how
   much does each page have in common with the other pages?  It may
   turn out that you can provide content pages as well as individual
   product pages with a single template.  This has the advantage of
   reducing maintenance hassle when making changes to HTML that you
   want to affect all pages.  On the other hand, it may be simpler to
   have several different templates for different kinds of pages than
   to have a single, massive template with a hundred [$ if(...) $]
   statements generating different variations on each part of a file.

   Another option here is to use the technique described for the
   sidebar boxes in the example layout.  A piece of HTML which needs
   to be created at regen time and used in random different pages
   might be best placed in a snippet belonging to some group, then
   either listed as a child of the pages which use it, or referenced
   by the group's name (as in the example).

   At this point, you may also want to start thinking about
   dependencies.  For example, the content of the pages in the example
   layout depended on the HTML generated by the sidebar groups.  The
   site layout may need to be altered accordingly. 

5. Templatize the example pages.  Most of the work is already done by
   now.  If you load the attributes for a page with REGEN::attrib() at
   the beginning of your template into appropriately named variables,
   you may find that many of the changes are as simple as this example:

   &lt;TABLE BGCOLOR="red"&gt;

   becomes...

   &lt;TABLE BGCOLOR="[+ $table_bg_color +]"&gt;

   Generating repetative bits of code like a list of products or a set
   of links can be accomplished with a 

   [$ foreach ... $] 

   ...  

   [$ endforeach $] 

   block, using a single item's HTML from the example code as a model
   for the rest.  This turns out to happen commonly enough that the
   function calls and [$ foreach ... $] embedded perl constructs
   themselves can be copied from an existing template, changing just
   the names of the attributes that will be used in the current
   situation.

6. Test the system.  If there are bugs in your embedded perl code, you
   may get odd, possibly even fatal error messages which can be hard
   to debug.  The embperl interpreter will occasionally jump to left
   field and need to be killed by hand.

   Turning on verbose fatal errors may be quite helpful; careful
   reading of the stack trace can tell you right where your template
   bombed.  Set the variable "$ugly_fatals" in lib/MILTON.pm to 1 to
   enable the stack trace.

   If you get cryptic messages about incomplete &lt;&gt; operators, check
   the value of $optDisableHtmlScan; if you use a text editor to write
   templates, you'll probably want to set this to 1.

   Also be aware of the $escmode variable, which can change things
   like &lt;&gt; in your output to &amp;lt;&amp;gt; and the like.



</pre> <br>
<br>

<hr noshade size=2 width=100%>
<font face="Verdana, Arial, Helvetica, sans-serif" size="1">
<a href="http://www.akopia.com/tallyman/"><b>Tallyman</b></a><a href="http://www.akopia.com/"><b> - &copy; 2000 Akopia, Inc.</b></a></font>

</td>
</tr>
</table>
</center>
</body>
</html>
